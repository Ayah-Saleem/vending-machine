<!doctype html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Vending Machine - State Pattern Implementation</title>
    <!-- QR Code Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, onValue, update } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        const firebaseConfig = {
            apiKey: "AIzaSyBzKF_fuEKbSP-8JuBZb9QkuMj9eGcBsYw",
            authDomain: "advanced-vending-machine.firebaseapp.com",
            databaseURL: "https://advanced-vending-machine-default-rtdb.firebaseio.com",
            projectId: "advanced-vending-machine",
            storageBucket: "advanced-vending-machine.firebasestorage.app",
            messagingSenderId: "119768375164",
            appId: "1:119768375164:web:d96d14021f495869474ef9",
            measurementId: "G-9935V0NKQ1"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        window.firebaseDB = database;
        window.firebaseRef = ref;
        window.firebaseSet = set;
        window.firebaseUpdate = update;
        window.firebaseOnValue = onValue;
        window.firebaseInitialized = true;
    </script>
    <style>
        /* ŸÜŸÅÿ≥ ÿßŸÑŸÄ CSS ÿßŸÑÿ≥ÿßÿ®ŸÇ - ŸÖÿ≠ŸÅŸàÿ∏ */
        body {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Cairo', 'Segoe UI', Tahoma, sans-serif;
            background: linear-gradient(135deg, #1e1b4b 0%, #312e81 50%, #1e1b4b 100%);
            width: 100%;
            min-height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-x: hidden;
        }

        * {
            box-sizing: border-box;
        }

        .machine-screen {
            width: 90%;
            max-width: 1400px;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-radius: 30px;
            padding: 40px 30px;
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.5),
                0 0 100px rgba(99, 102, 241, 0.3),
                inset 0 0 30px rgba(99, 102, 241, 0.1);
            border: 3px solid rgba(99, 102, 241, 0.3);
            position: relative;
            overflow: hidden;
        }

        .machine-screen::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(99, 102, 241, 0.1) 0%, transparent 70%);
            animation: rotate 20s linear infinite;
            pointer-events: none;
        }

        @keyframes rotate {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .machine-header {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
            z-index: 1;
        }

        .machine-title {
            font-size: 42px;
            font-weight: 900;
            color: #ffffff;
            margin: 0;
            text-shadow: 0 0 30px rgba(99, 102, 241, 0.5);
            animation: pulse 3s ease-in-out infinite;
            letter-spacing: 2px;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.9;
                transform: scale(1.02);
            }
        }

        /* Display Area */
        .display-area {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.8) 0%, rgba(30, 41, 59, 0.8) 100%);
            border-radius: 25px;
            padding: 30px;
            min-height: 320px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 2px solid rgba(99, 102, 241, 0.2);
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 50px rgba(99, 102, 241, 0.2);
            margin-bottom: 30px;
            z-index: 1;
        }

        .display-area::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 50% 50%, rgba(99, 102, 241, 0.1) 0%, transparent 70%),
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(99, 102, 241, 0.03) 2px, rgba(99, 102, 241, 0.03) 4px);
            pointer-events: none;
            animation: scanline 8s linear infinite;
        }

        @keyframes scanline {
            0% {
                transform: translateY(-100%);
            }

            100% {
                transform: translateY(100%);
            }
        }

        .qr-display {
            text-align: center;
            animation: fadeInUp 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            position: relative;
            z-index: 1;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(40px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .qr-code-container {
            width: 200px;
            height: 200px;
            background: white;
            border-radius: 15px;
            padding: 15px;
            margin: 0 auto 20px;
            box-shadow: 0 15px 30px rgba(99, 102, 241, 0.4), 0 0 0 5px rgba(99, 102, 241, 0.2);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        #qrcode {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #qrcode img {
            display: block;
            margin: 0 auto;
            border-radius: 15px;
        }

        .qr-instruction {
            font-size: 16px;
            color: #ffffff;
            margin-bottom: 6px;
            font-weight: 800;
            text-shadow: 0 0 15px rgba(99, 102, 241, 0.6);
        }

        .qr-subtext {
            font-size: 13px;
            color: #a5b4fc;
            font-weight: 600;
        }

        .timer-info {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 8px 15px;
            margin-top: 10px;
            border: 2px solid rgba(245, 158, 11, 0.3);
            display: inline-block;
        }

        .timer-text {
            color: #fbbf24;
            font-weight: 700;
            font-size: 13px;
        }

        .timer-value {
            color: #ffffff;
            font-weight: 900;
            font-size: 16px;
            text-shadow: 0 0 10px rgba(245, 158, 11, 0.8);
        }

        .order-details {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.15) 0%, rgba(139, 92, 246, 0.15) 100%);
            border: 3px solid #6366f1;
            border-radius: 20px;
            padding: 25px;
            margin-top: 20px;
            max-width: 400px;
            width: 100%;
            position: relative;
            z-index: 1;
            box-shadow: 0 15px 35px rgba(99, 102, 241, 0.3);
            animation: fadeInUp 0.5s ease-out;
        }

        .order-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 2px solid rgba(99, 102, 241, 0.3);
            color: #ffffff;
            font-size: 16px;
            font-weight: 600;
        }

        .order-item:last-child {
            border-bottom: none;
        }

        .order-label {
            color: #a5b4fc;
            font-weight: 700;
        }

        .order-value {
            font-weight: 900;
            font-size: 18px;
            text-shadow: 0 0 8px rgba(99, 102, 241, 0.5);
        }

        .pickup-message {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            color: white;
            padding: 20px;
            border-radius: 20px;
            margin-top: 20px;
            font-size: 20px;
            font-weight: 900;
            text-align: center;
            animation: pulse 1.5s ease-in-out infinite;
            position: relative;
            z-index: 1;
            box-shadow: 0 15px 35px rgba(34, 197, 94, 0.5), 0 0 40px rgba(34, 197, 94, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.3);
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* State Machine Diagram */
        .state-diagram-container {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.8) 0%, rgba(30, 41, 59, 0.8) 100%);
            border-radius: 25px;
            padding: 30px;
            border: 2px solid rgba(99, 102, 241, 0.2);
            box-shadow: inset 0 0 50px rgba(99, 102, 241, 0.2);
            position: relative;
            z-index: 1;
        }

        .diagram-title {
            font-size: 24px;
            font-weight: 900;
            color: #ffffff;
            margin-bottom: 25px;
            text-align: center;
        }

        .state-flow {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: auto auto;
            gap: 10px;
            align-items: center;
        }

        .state-node {
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.9) 0%, rgba(15, 23, 42, 0.9) 100%);
            border: 2px solid rgba(99, 102, 241, 0.3);
            border-radius: 12px;
            padding: 12px 10px;
            text-align: center;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            position: relative;
        }

        .state-node.active {
            border-color: #22c55e;
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.3) 0%, rgba(16, 185, 129, 0.3) 100%);
            box-shadow: 0 0 30px rgba(34, 197, 94, 0.6), inset 0 0 20px rgba(34, 197, 94, 0.2);
            transform: scale(1.05);
            animation: activeGlow 2s ease-in-out infinite;
        }

        @keyframes activeGlow {

            0%,
            100% {
                box-shadow: 0 0 30px rgba(34, 197, 94, 0.6), inset 0 0 20px rgba(34, 197, 94, 0.2);
            }

            50% {
                box-shadow: 0 0 50px rgba(34, 197, 94, 0.8), inset 0 0 30px rgba(34, 197, 94, 0.4);
            }
        }

        .state-node.completed {
            border-color: rgba(99, 102, 241, 0.5);
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.2) 0%, rgba(139, 92, 246, 0.2) 100%);
            opacity: 0.7;
        }

        .state-node-name {
            font-size: 11px;
            font-weight: 900;
            color: #ffffff;
            margin-bottom: 3px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .state-node-desc {
            font-size: 9px;
            color: #a5b4fc;
            font-weight: 600;
        }

        .state-arrow {
            text-align: center;
            font-size: 18px;
            color: #6366f1;
            animation: bounceX 2s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .state-arrow.active {
            color: #22c55e;
            animation: bounceX 1s ease-in-out infinite;
        }

        @keyframes bounceX {

            0%,
            100% {
                transform: translateX(0);
            }

            50% {
                transform: translateX(5px);
            }
        }

        /* Grid positioning */
        .state-node[data-state="IDLE"] {
            grid-column: 1;
            grid-row: 1;
        }

        .state-arrow:nth-child(2) {
            grid-column: 2;
            grid-row: 1;
        }

        .state-node[data-state="PRODUCT_SELECTED"] {
            grid-column: 3;
            grid-row: 1;
        }

        .state-arrow:nth-child(4) {
            grid-column: 4;
            grid-row: 1;
        }

        .state-node[data-state="WAITING_PAYMENT"] {
            grid-column: 5;
            grid-row: 1;
        }

        .state-arrow:nth-child(6) {
            grid-column: 6;
            grid-row: 1;
        }

        .state-node[data-state="PAYMENT_CONFIRMED"] {
            grid-column: 7;
            grid-row: 1;
        }

        .state-arrow:nth-child(8) {
            grid-column: 8;
            grid-row: 1;
            transform: rotate(90deg);
        }

        .state-node[data-state="DISPENSING"] {
            grid-column: 7;
            grid-row: 2;
        }

        .state-arrow:nth-child(10) {
            grid-column: 6;
            grid-row: 2;
            transform: scaleX(-1);
        }

        .state-node[data-state="RETURNING_CHANGE"] {
            grid-column: 5;
            grid-row: 2;
        }

        .state-arrow:nth-child(12) {
            grid-column: 4;
            grid-row: 2;
            transform: scaleX(-1);
        }

        .state-node[data-state="COMPLETE"] {
            grid-column: 3;
            grid-row: 2;
        }

        .state-arrow:nth-child(14) {
            grid-column: 2;
            grid-row: 2;
            transform: scaleX(-1);
        }

        @media (max-width: 768px) {
            .machine-screen {
                width: 95%;
                padding: 30px 20px;
            }

            .machine-title {
                font-size: 36px;
            }

            .display-area {
                padding: 25px 20px;
                min-height: 280px;
            }

            .qr-code-container {
                width: 180px;
                height: 180px;
            }

            .state-node-name {
                font-size: 9px;
            }

            .state-node-desc {
                font-size: 8px;
            }
        }
    </style>
</head>

<body>
    <div class="machine-screen">
        <header class="machine-header">
            <h1 class="machine-title">ü§ñ VENDING MACHINE</h1>
        </header>
        <main class="display-area" id="displayArea">
            <!-- ÿ≥Ÿäÿ™ŸÖ ŸÖŸÑÿ§Ÿá ÿØŸäŸÜÿßŸÖŸäŸÉŸäÿßŸã -->
        </main>
        <div class="state-diagram-container">
            <div class="diagram-title">üìä State Machine Diagram</div>
            <div class="state-flow" id="stateFlow">
                <div class="state-node" data-state="IDLE">
                    <div class="state-node-name">üîµ IDLE</div>
                    <div class="state-node-desc">ÿ¨ÿßŸáÿ≤ ŸÑŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ</div>
                </div>
                <div class="state-arrow">‚¨ÖÔ∏è</div>
                <div class="state-node" data-state="PRODUCT_SELECTED">
                    <div class="state-node-name">üõí PRODUCT SELECTED</div>
                    <div class="state-node-desc">ÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸÖŸÜÿ™ÿ¨</div>
                </div>
                <div class="state-arrow">‚¨ÖÔ∏è</div>
                <div class="state-node" data-state="WAITING_PAYMENT">
                    <div class="state-node-name">‚è≥ WAITING PAYMENT</div>
                    <div class="state-node-desc">ÿßŸÜÿ™ÿ∏ÿßÿ± ÿßŸÑÿØŸÅÿπ</div>
                </div>
                <div class="state-arrow">‚¨ÖÔ∏è</div>
                <div class="state-node" data-state="PAYMENT_CONFIRMED">
                    <div class="state-node-name">‚úÖ PAYMENT CONFIRMED</div>
                    <div class="state-node-desc">ÿ™ŸÖ ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿØŸÅÿπ</div>
                </div>
                <div class="state-arrow">‚¨áÔ∏è</div>
                <div class="state-node" data-state="DISPENSING">
                    <div class="state-node-name">‚öôÔ∏è DISPENSING</div>
                    <div class="state-node-desc">ÿ¨ÿßÿ±Ÿä ÿßŸÑÿµÿ±ŸÅ</div>
                </div>
                <div class="state-arrow">‚û°Ô∏è</div>
                <div class="state-node" data-state="RETURNING_CHANGE">
                    <div class="state-node-name">üí∞ RETURNING CHANGE</div>
                    <div class="state-node-desc">ÿ•ÿ±ÿ¨ÿßÿπ ÿßŸÑÿ®ÿßŸÇŸä</div>
                </div>
                <div class="state-arrow">‚û°Ô∏è</div>
                <div class="state-node" data-state="COMPLETE">
                    <div class="state-node-name">‚úÖ COMPLETE</div>
                    <div class="state-node-desc">ÿßŸÉÿ™ŸÖŸÑÿ™ ÿßŸÑÿπŸÖŸÑŸäÿ©</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // VENDING MACHINE - STATE PATTERN IMPLEMENTATION (THEORY OF COMPUTATION)
        // ============================================================================

        const MACHINE_ID = 'VM-001';

        /**
         * ============================================
         * EVENT BUS (Event-Driven Architecture)
         * ============================================
         * Implements Observer Pattern for decoupled communication
         */
        class EventBus {
            constructor() {
                this.listeners = new Map();
            }

            subscribe(eventType, callback) {
                if (!this.listeners.has(eventType)) {
                    this.listeners.set(eventType, []);
                }
                this.listeners.get(eventType).push(callback);
                console.log(`[EVENT] Subscribed to: ${eventType}`);
            }

            unsubscribe(eventType, callback) {
                if (this.listeners.has(eventType)) {
                    const callbacks = this.listeners.get(eventType);
                    const index = callbacks.indexOf(callback);
                    if (index > -1) {
                        callbacks.splice(index, 1);
                    }
                }
            }

            publish(eventType, data) {
                console.log(`[EVENT] Published: ${eventType}`, data);
                if (this.listeners.has(eventType)) {
                    this.listeners.get(eventType).forEach(callback => {
                        try {
                            callback(data);
                        } catch (error) {
                            console.error(`[EVENT] Error in listener for ${eventType}:`, error);
                        }
                    });
                }
            }
        }

        /**
         * ============================================
         * STATE ABSTRACT CLASS (State Design Pattern)
         * ============================================
         * Base class for all concrete state implementations
         */
        class VendingMachineState {
            constructor(context) {
                this.context = context;
                this.name = this.constructor.name;
            }

            // Template methods
            onEnter() {
                console.log(`[STATE] Entered: ${this.name}`);
            }

            onExit() {
                console.log(`[STATE] Exited: ${this.name}`);
            }

            handleEvent(event) {
                console.log(`[STATE] ${this.name} handling event: ${event.type}`);
            }

            getDisplayHTML() {
                return `<div>Default State Display</div>`;
            }

            getTimerDuration() {
                return 0; // Default no timer
            }

            startTimer() {
                // Override in subclasses
            }

            cleanup() {
                // Cleanup resources
            }
        }

        /**
         * ============================================
         * CONCRETE STATE CLASSES (State Design Pattern)
         * ============================================
         * Each state has its own class with specific behavior
         */

        class IdleState extends VendingMachineState {
            onEnter() {
                super.onEnter();
                this.generateQRCode();
                this.startTimer(120); // 2 minutes
            }

            handleEvent(event) {
                super.handleEvent(event);
                switch (event.type) {
                    case 'PRODUCT_SELECTED':
                        this.context.transitionTo(new ProductSelectedState(this.context, event.data));
                        break;
                    case 'TIMEOUT':
                        console.log('[IDLE] Timeout occurred, staying in IDLE');
                        break;
                }
            }

            getDisplayHTML() {
                return `
                    <div class="qr-display">
                        <div class="qr-code-container">
                            <div id="qrcode"></div>
                        </div>
                        <div class="qr-instruction">üì± ÿßŸÖÿ≥ÿ≠ ÿßŸÑŸÉŸàÿØ ÿ®Ÿáÿßÿ™ŸÅŸÉ ŸÑŸÑÿ®ÿØÿ°</div>
                        <div class="qr-subtext">Scan QR code to start payment</div>
                       
                `;
            }

            generateQRCode() {
                setTimeout(() => {
                    const qrcodeContainer = document.getElementById('qrcode');
                    if (!qrcodeContainer) return;

                    qrcodeContainer.innerHTML = '';
                    const mobileAppUrl = `https://ayah-saleem.github.io/mobile-payment/mobile.html?machine=${MACHINE_ID}`;

                    if (typeof QRCode !== 'undefined') {
                        new QRCode(qrcodeContainer, {
                            text: mobileAppUrl,
                            width: 170,
                            height: 170,
                            colorDark: "#000000",
                            colorLight: "#ffffff",
                            correctLevel: QRCode.CorrectLevel.H
                        });
                    }
                }, 100);
            }

            startTimer(seconds) {
                this.clearTimer();
                this.timer = setTimeout(() => {
                    this.context.eventBus.publish('TIMEOUT', {
                        state: 'IDLE',
                        reason: 'ÿßŸÜÿ™ŸáŸâ ŸàŸÇÿ™ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±'
                    });
                }, seconds * 1000);
            }

            clearTimer() {
                if (this.timer) {
                    clearTimeout(this.timer);
                    this.timer = null;
                }
            }

            onExit() {
                super.onExit();
                this.clearTimer();
            }
        }

        class ProductSelectedState extends VendingMachineState {
            constructor(context, productData) {
                super(context);
                this.productData = productData;
            }

            onEnter() {
                super.onEnter();
                this.startTimer(60); // 1 minute
            }

            handleEvent(event) {
                super.handleEvent(event);
                switch (event.type) {
                    case 'PAYMENT_STARTED':
                        this.context.transitionTo(new WaitingPaymentState(this.context, this.productData));
                        break;
                    case 'CANCEL':
                        this.context.transitionTo(new IdleState(this.context));
                        break;
                    case 'TIMEOUT':
                        this.context.transitionTo(new IdleState(this.context));
                        break;
                }
            }

            getDisplayHTML() {
                return `
                    <div class="qr-display">
                        <div class="order-details">
                            <div class="order-item">
                                <span class="order-label">ÿßŸÑŸÖŸÜÿ™ÿ¨:</span>
                                <span class="order-value">${this.productData.icon || ''} ${this.productData.name || ''}</span>
                            </div>
                            <div class="order-item">
                                <span class="order-label">ÿßŸÑÿ≥ÿπÿ±:</span>
                                <span class="order-value">${(this.productData.price || 0).toFixed(2)} ‚Ç™</span>
                            </div>
                            <div class="order-item">
                                <span class="order-label">‚è∞ ÿßŸÑŸàŸÇÿ™ ŸÑŸÑÿØŸÅÿπ:</span>
                                <span class="order-value">60 ÿ´ÿßŸÜŸäÿ©</span>
                            </div>
                        </div>
                        <div class="timer-info">
                            <span class="timer-text">‚è∞ ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖÿ™ÿ®ŸÇŸä ŸÑŸÑÿØŸÅÿπ:</span>
                            <span class="timer-value">60</span> ÿ´ÿßŸÜŸäÿ©
                        </div>
                    </div>
                `;
            }

            startTimer(seconds) {
                this.clearTimer();
                this.timer = setTimeout(() => {
                    this.context.eventBus.publish('TIMEOUT', {
                        state: 'PRODUCT_SELECTED',
                        reason: 'ÿßŸÜÿ™ŸáŸâ ŸàŸÇÿ™ ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸÖŸÜÿ™ÿ¨'
                    });
                }, seconds * 1000);
            }

            clearTimer() {
                if (this.timer) {
                    clearTimeout(this.timer);
                    this.timer = null;
                }
            }

            onExit() {
                super.onExit();
                this.clearTimer();
            }
        }

        class WaitingPaymentState extends VendingMachineState {
            constructor(context, productData) {
                super(context);
                this.productData = productData;
            }

            onEnter() {
                super.onEnter();
                this.startTimer(60); // 1 minute
            }

            handleEvent(event) {
                super.handleEvent(event);
                switch (event.type) {
                    case 'PAYMENT_CONFIRMED':
                        this.context.transitionTo(new PaymentConfirmedState(this.context, {
                            ...this.productData,
                            payment: event.data
                        }));
                        break;
                    case 'CANCEL':
                        this.context.transitionTo(new IdleState(this.context));
                        break;
                    case 'TIMEOUT':
                        this.context.transitionTo(new IdleState(this.context));
                        break;
                }
            }

            getDisplayHTML() {
                return `
                    <div class="qr-display">
                        <div class="order-details">
                            <div class="order-item">
                                <span class="order-label">ÿßŸÑŸÖŸÜÿ™ÿ¨:</span>
                                <span class="order-value">${this.productData.icon || ''} ${this.productData.name || ''}</span>
                            </div>
                            <div class="order-item">
                                <span class="order-label">ÿßŸÑÿ≥ÿπÿ±:</span>
                                <span class="order-value">${(this.productData.price || 0).toFixed(2)} ‚Ç™</span>
                            </div>
                            <div class="order-item">
                                <span class="order-label">ÿßŸÑŸÖÿ∑ŸÑŸàÿ®:</span>
                                <span class="order-value" style="color: #fbbf24;">${(this.productData.price || 0).toFixed(2)} ‚Ç™</span>
                            </div>
                        </div>
                        <div class="timer-info">
                            <span class="timer-text">‚è∞ ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖÿ™ÿ®ŸÇŸä ŸÑŸÑÿ•ŸÑÿ∫ÿßÿ°:</span>
                            <span class="timer-value">60</span> ÿ´ÿßŸÜŸäÿ©
                        </div>
                    </div>
                `;
            }

            startTimer(seconds) {
                this.clearTimer();
                this.timer = setTimeout(() => {
                    this.context.eventBus.publish('TIMEOUT', {
                        state: 'WAITING_PAYMENT',
                        reason: 'ÿßŸÜÿ™ŸáŸâ ŸàŸÇÿ™ ÿßŸÑÿØŸÅÿπ'
                    });
                }, seconds * 1000);
            }

            clearTimer() {
                if (this.timer) {
                    clearTimeout(this.timer);
                    this.timer = null;
                }
            }

            onExit() {
                super.onExit();
                this.clearTimer();
            }
        }

        class PaymentConfirmedState extends VendingMachineState {
            constructor(context, transactionData) {
                super(context);
                this.transactionData = transactionData;
            }

            onEnter() {
                super.onEnter();
                // Auto transition to dispensing after 2 seconds
                setTimeout(() => {
                    this.context.transitionTo(new DispensingState(this.context, this.transactionData));
                }, 2000);
            }

            getDisplayHTML() {
                return `
                    <div class="qr-display">
                        <div class="order-details">
                            <div class="order-item">
                                <span class="order-label">ÿßŸÑŸÖŸÜÿ™ÿ¨:</span>
                                <span class="order-value">${this.transactionData.icon || ''} ${this.transactionData.name || ''}</span>
                            </div>
                            <div class="order-item">
                                <span class="order-label">ÿßŸÑÿ≥ÿπÿ±:</span>
                                <span class="order-value">${(this.transactionData.price || 0).toFixed(2)} ‚Ç™</span>
                            </div>
                            <div class="order-item">
                                <span class="order-label">ÿßŸÑŸÖÿØŸÅŸàÿπ:</span>
                                <span class="order-value" style="color: #22c55e;">${(this.transactionData.payment?.amountPaid || 0).toFixed(2)} ‚Ç™</span>
                            </div>
                            <div class="order-item">
                                <span class="order-label">ÿßŸÑÿ≠ÿßŸÑÿ©:</span>
                                <span class="order-value">‚úÖ ÿ™ŸÖ ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿØŸÅÿπ</span>
                            </div>
                        </div>
                    </div>
                `;
            }
        }

        class DispensingState extends VendingMachineState {
            constructor(context, transactionData) {
                super(context);
                this.transactionData = transactionData;
            }

            onEnter() {
                super.onEnter();
                // Auto transition to returning change or complete after 3 seconds
                setTimeout(() => {
                    if (this.transactionData.payment?.change > 0) {
                        this.context.transitionTo(new ReturningChangeState(this.context, this.transactionData));
                    } else {
                        this.context.transitionTo(new CompleteState(this.context, this.transactionData));
                    }
                }, 3000);
            }

            getDisplayHTML() {
                return `
                    <div class="qr-display">
                        <div class="order-details">
                            <div class="order-item">
                                <span class="order-label">ÿßŸÑŸÖŸÜÿ™ÿ¨:</span>
                                <span class="order-value">${this.transactionData.icon || ''} ${this.transactionData.name || ''}</span>
                            </div>
                            <div class="order-item">
                                <span class="order-label">ÿßŸÑÿ≥ÿπÿ±:</span>
                                <span class="order-value">${(this.transactionData.price || 0).toFixed(2)} ‚Ç™</span>
                            </div>
                            <div class="order-item">
                                <span class="order-label">ÿßŸÑŸÖÿØŸÅŸàÿπ:</span>
                                <span class="order-value" style="color: #22c55e;">${(this.transactionData.payment?.amountPaid || 0).toFixed(2)} ‚Ç™</span>
                            </div>
                            <div class="order-item">
                                <span class="order-label">‚è∞ ÿßŸÑÿ≠ÿßŸÑÿ©:</span>
                                <span class="order-value">ÿ¨ÿßÿ±Ÿä ÿµÿ±ŸÅ ÿßŸÑŸÖŸÜÿ™ÿ¨...</span>
                            </div>
                        </div>
                    </div>
                `;
            }
        }

        class ReturningChangeState extends VendingMachineState {
            constructor(context, transactionData) {
                super(context);
                this.transactionData = transactionData;
            }

            onEnter() {
                super.onEnter();
                // Auto transition to complete after 2 seconds
                setTimeout(() => {
                    this.context.transitionTo(new CompleteState(this.context, this.transactionData));
                }, 2000);
            }

            getDisplayHTML() {
                return `
                    <div class="qr-display">
                        <div class="order-details">
                            <div class="order-item">
                                <span class="order-label">ÿßŸÑŸÖŸÜÿ™ÿ¨:</span>
                                <span class="order-value">${this.transactionData.icon || ''} ${this.transactionData.name || ''}</span>
                            </div>
                            <div class="order-item">
                                <span class="order-label">ÿßŸÑÿ≥ÿπÿ±:</span>
                                <span class="order-value">${(this.transactionData.price || 0).toFixed(2)} ‚Ç™</span>
                            </div>
                            <div class="order-item">
                                <span class="order-label">ÿßŸÑŸÖÿØŸÅŸàÿπ:</span>
                                <span class="order-value" style="color: #22c55e;">${(this.transactionData.payment?.amountPaid || 0).toFixed(2)} ‚Ç™</span>
                            </div>
                            <div class="order-item">
                                <span class="order-label">ÿßŸÑÿ®ÿßŸÇŸä:</span>
                                <span class="order-value" style="color: #fbbf24;">${(this.transactionData.payment?.change || 0).toFixed(2)} ‚Ç™</span>
                            </div>
                            <div class="order-item">
                                <span class="order-label">‚è∞ ÿßŸÑÿ≠ÿßŸÑÿ©:</span>
                                <span class="order-value">ÿ¨ÿßÿ±Ÿä ÿ•ÿ±ÿ¨ÿßÿπ ÿßŸÑÿ®ÿßŸÇŸä...</span>
                            </div>
                        </div>
                    </div>
                `;
            }
        }

        class CompleteState extends VendingMachineState {
            constructor(context, transactionData) {
                super(context);
                this.transactionData = transactionData;
            }

            onEnter() {
                super.onEnter();
                this.startTimer(60); // 1 minute
            }

            handleEvent(event) {
                super.handleEvent(event);
                switch (event.type) {
                    case 'RESET':
                        this.context.transitionTo(new IdleState(this.context));
                        break;
                    case 'TIMEOUT':
                        this.context.transitionTo(new IdleState(this.context));
                        break;
                }
            }

            getDisplayHTML() {
                const change = this.transactionData.payment?.change || 0;
                return `
                    <div class="qr-display">
                        <div class="order-details">
                            <div class="order-item">
                                <span class="order-label">ÿßŸÑŸÖŸÜÿ™ÿ¨:</span>
                                <span class="order-value">${this.transactionData.icon || ''} ${this.transactionData.name || ''}</span>
                            </div>
                            <div class="order-item">
                                <span class="order-label">ÿßŸÑÿ≥ÿπÿ±:</span>
                                <span class="order-value">${(this.transactionData.price || 0).toFixed(2)} ‚Ç™</span>
                            </div>
                            <div class="order-item">
                                <span class="order-label">ÿßŸÑŸÖÿØŸÅŸàÿπ:</span>
                                <span class="order-value" style="color: #22c55e;">${(this.transactionData.payment?.amountPaid || 0).toFixed(2)} ‚Ç™</span>
                            </div>
                            ${change > 0 ? `
                            <div class="order-item">
                                <span class="order-label">ÿßŸÑÿ®ÿßŸÇŸä:</span>
                                <span class="order-value" style="color: #fbbf24;">${change.toFixed(2)} ‚Ç™</span>
                            </div>
                            ` : ''}
                        </div>
                        <div class="pickup-message">
                            üì¶ ÿßÿ≥ÿ™ŸÑŸÖ ÿ∑ŸÑÿ®ŸÉ!
                        </div>
                        <div class="timer-info">
                            <span class="timer-text">‚è∞ ÿßŸÑÿπŸàÿØÿ© ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿäÿ© ÿÆŸÑÿßŸÑ:</span>
                            <span class="timer-value">60</span> ÿ´ÿßŸÜŸäÿ©
                        </div>
                    </div>
                `;
            }

            startTimer(seconds) {
                this.clearTimer();
                this.timer = setTimeout(() => {
                    this.context.eventBus.publish('TIMEOUT', {
                        state: 'COMPLETE',
                        reason: 'ÿßŸÜÿ™ŸáŸâ ŸàŸÇÿ™ ÿßŸÑÿßÿ≥ÿ™ŸÑÿßŸÖ'
                    });
                }, seconds * 1000);
            }

            clearTimer() {
                if (this.timer) {
                    clearTimeout(this.timer);
                    this.timer = null;
                }
            }

            onExit() {
                super.onExit();
                this.clearTimer();
            }
        }

        /**
         * ============================================
         * VENDING MACHINE MODEL (Model-View Separation)
         * ============================================
         * Pure business logic, no UI concerns
         */
        class VendingMachineModel {
            constructor() {
                this.eventBus = new EventBus();
                this.currentState = new IdleState(this);
                this.currentState.onEnter();

                // Initialize Firebase listener
                this.waitForFirebase();

                // Listen to internal events
                this.setupEventListeners();
            }

            transitionTo(newState) {
                console.log(`[MODEL] Transitioning from ${this.currentState.name} to ${newState.name}`);

                // Exit current state
                this.currentState.onExit();
                this.currentState.cleanup();

                // Update state
                this.currentState = newState;

                // Enter new state
                this.currentState.onEnter();

                // Update Firebase
                this.updateFirebaseState();

                // Notify View
                this.eventBus.publish('STATE_CHANGED', {
                    state: this.currentState,
                    stateName: this.currentState.name
                });
            }

            handleEvent(event) {
                this.currentState.handleEvent(event);
            }

            waitForFirebase() {
                if (window.firebaseInitialized && window.firebaseDB) {
                    console.log('[MODEL] Firebase initialized');
                    this.setupFirebaseListener();
                } else {
                    setTimeout(() => this.waitForFirebase(), 100);
                }
            }

            setupFirebaseListener() {
                const sessionRef = window.firebaseRef(window.firebaseDB, `machines/${MACHINE_ID}/session`);

                window.firebaseOnValue(sessionRef, (snapshot) => {
                    const session = snapshot.val();
                    if (!session) return;

                    console.log('[MODEL] Firebase update:', session.state);

                    // Map Firebase state to internal events
                    switch (session.state) {
                        case 'PRODUCT_SELECTED':
                            this.eventBus.publish('PRODUCT_SELECTED', {
                                name: session.productName,
                                icon: session.productIcon,
                                price: session.productPrice
                            });
                            break;
                        case 'WAITING_PAYMENT':
                            this.eventBus.publish('PAYMENT_STARTED', {
                                amount: session.productPrice
                            });
                            break;
                        case 'PAYMENT_CONFIRMED':
                            this.eventBus.publish('PAYMENT_CONFIRMED', {
                                amountPaid: session.amountPaid,
                                change: session.change
                            });
                            break;
                        case 'IDLE':
                            if (session.resetReason) {
                                this.eventBus.publish('RESET', { reason: session.resetReason });
                            }
                            break;
                    }
                });
            }

            updateFirebaseState() {
                if (!window.firebaseDB) return;

                const stateName = this.currentState.name.replace('State', '').toUpperCase();
                const sessionRef = window.firebaseRef(window.firebaseDB, `machines/${MACHINE_ID}/session`);

                let sessionData = {
                    state: stateName,
                    timestamp: Date.now()
                };

                // Add product data if available
                if (this.currentState.productData || this.currentState.transactionData) {
                    const data = this.currentState.productData || this.currentState.transactionData;
                    sessionData.productName = data.name;
                    sessionData.productIcon = data.icon;
                    sessionData.productPrice = data.price;

                    if (data.payment) {
                        sessionData.amountPaid = data.payment.amountPaid;
                        sessionData.change = data.payment.change;
                    }
                }

                window.firebaseSet(sessionRef, sessionData);
            }

            setupEventListeners() {
                // Internal event handlers
                this.eventBus.subscribe('PRODUCT_SELECTED', (data) => {
                    this.handleEvent({ type: 'PRODUCT_SELECTED', data });
                });

                this.eventBus.subscribe('PAYMENT_STARTED', (data) => {
                    this.handleEvent({ type: 'PAYMENT_STARTED', data });
                });

                this.eventBus.subscribe('PAYMENT_CONFIRMED', (data) => {
                    this.handleEvent({ type: 'PAYMENT_CONFIRMED', data });
                });

                this.eventBus.subscribe('CANCEL', () => {
                    this.handleEvent({ type: 'CANCEL' });
                });

                this.eventBus.subscribe('RESET', () => {
                    this.handleEvent({ type: 'RESET' });
                });

                this.eventBus.subscribe('TIMEOUT', (data) => {
                    this.handleEvent({ type: 'TIMEOUT', data });
                });
            }

            getCurrentState() {
                return this.currentState;
            }
        }

        /**
         * ============================================
         * VENDING MACHINE VIEW (Model-View Separation)
         * ============================================
         * Only handles UI rendering, no business logic
         */
        class VendingMachineView {
            constructor(model) {
                this.model = model;
                this.displayArea = document.getElementById('displayArea');

                // Subscribe to model changes
                this.model.eventBus.subscribe('STATE_CHANGED', (data) => {
                    this.render(data.state);
                    this.updateStateDiagram(data.stateName);
                });

                // Initial render
                this.render(this.model.getCurrentState());
            }

            render(state) {
                if (!this.displayArea) return;

                this.displayArea.innerHTML = state.getDisplayHTML();

                // Special handling for QR code in Idle state
                if (state.name === 'IdleState') {
                    setTimeout(() => {
                        const qrcodeContainer = document.getElementById('qrcode');
                        if (qrcodeContainer && typeof QRCode !== 'undefined') {
                            const mobileAppUrl = `https://ayah-saleem.github.io/mobile-payment/mobile.html?machine=${MACHINE_ID}`;
                            qrcodeContainer.innerHTML = '';
                            new QRCode(qrcodeContainer, {
                                text: mobileAppUrl,
                                width: 170,
                                height: 170,
                                colorDark: "#000000",
                                colorLight: "#ffffff",
                                correctLevel: QRCode.CorrectLevel.H
                            });
                        }
                    }, 100);
                }
            }

            updateStateDiagram(currentStateName) {
                const allNodes = document.querySelectorAll('.state-node');
                const allArrows = document.querySelectorAll('.state-arrow');

                // Remove all active/completed classes
                allNodes.forEach(node => {
                    node.classList.remove('active', 'completed');
                });

                allArrows.forEach(arrow => {
                    arrow.classList.remove('active');
                });

                // Map state class names to diagram state names
                const stateMap = {
                    'IdleState': 'IDLE',
                    'ProductSelectedState': 'PRODUCT_SELECTED',
                    'WaitingPaymentState': 'WAITING_PAYMENT',
                    'PaymentConfirmedState': 'PAYMENT_CONFIRMED',
                    'DispensingState': 'DISPENSING',
                    'ReturningChangeState': 'RETURNING_CHANGE',
                    'CompleteState': 'COMPLETE'
                };

                const diagramStateName = stateMap[currentStateName] || currentStateName;
                const currentNode = document.querySelector(`[data-state="${diagramStateName}"]`);

                if (currentNode) {
                    currentNode.classList.add('active');

                    // Mark previous states as completed
                    const stateOrder = ['IDLE', 'PRODUCT_SELECTED', 'WAITING_PAYMENT',
                        'PAYMENT_CONFIRMED', 'DISPENSING', 'RETURNING_CHANGE', 'COMPLETE'];
                    const currentIndex = stateOrder.indexOf(diagramStateName);

                    for (let i = 0; i < currentIndex; i++) {
                        const node = document.querySelector(`[data-state="${stateOrder[i]}"]`);
                        if (node) {
                            node.classList.add('completed');
                        }
                    }

                    // Mark arrows as active
                    allArrows.forEach((arrow, index) => {
                        if (index < currentIndex) {
                            arrow.classList.add('active');
                        }
                    });
                }
            }
        }

        /**
         * ============================================
         * FINITE AUTOMATON DOCUMENTATION
         * ============================================
         * Formal definition as per Theory of Computation requirements
         * 
         * Finite Automaton M = (Q, Œ£, Œ¥, q0, F)
         * 
         * Q = {IdleState, ProductSelectedState, WaitingPaymentState,
         *      PaymentConfirmedState, DispensingState, 
         *      ReturningChangeState, CompleteState}
         * 
         * Œ£ = {PRODUCT_SELECTED, PAYMENT_STARTED, PAYMENT_CONFIRMED,
         *      CANCEL, RESET, TIMEOUT}
         * 
         * Œ¥: Transition function (implemented in handleEvent() methods)
         * 
         * q0 = IdleState (initial state)
         * 
         * F = {CompleteState} (accepting/final state)
         * 
         * Language L = Sequence of valid transactions:
         * L = {PRODUCT_SELECTED ‚Üí PAYMENT_STARTED ‚Üí PAYMENT_CONFIRMED
         *      ‚Üí [RETURNING_CHANGE] ‚Üí COMPLETE}
         */

        // Initialize the application
        window.addEventListener('load', () => {
            console.log('[APP] Initializing Vending Machine with State Pattern...');

            // Create Model (business logic)
            const model = new VendingMachineModel();

            // Create View (UI)
            new VendingMachineView(model);

            console.log('[APP] Vending Machine initialized successfully!');
            console.log('[APP] State Pattern ‚úì | Event-Driven Architecture ‚úì | Model-View Separation ‚úì');
        });
    </script>
</body>

</html>
